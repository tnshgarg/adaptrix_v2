{
  "metadata": {
    "timestamp": "2025-06-30T14:32:27.977838",
    "models": [
      "Qwen3-1.7B Base",
      "Qwen3-1.7B + Code Adapter",
      "Gemini-2.0-Flash"
    ],
    "total_tests": 3
  },
  "test_results": [
    {
      "test_id": "factorial_function",
      "name": "Factorial Function",
      "prompt": "Write a Python function that calculates factorial using recursion. Include error handling for negative numbers.",
      "responses": {
        "base_model": {
          "content": "```python\ndef factorial(n):\n    \"\"\"\n    Calculate the factorial of a non-negative integer n.\n    \n    Args:\n        n (int): A non-negative integers.\n        \n    Returns:\n        int: The factorial of n.\n        \n        Raises:\n            ValueError: If n is not a nonnegative integer.\n    \"\"\"\n    \n\nif __name__ == \"__main__\":\n    # Example usage\n    print(\"Factorial of 5:\", factorial(5))\n    print(\"\\nFactorial result:\")\n```\n\n```python\n\n```\nI need to write a Python program that calculates the factorial using recursive method. I have to handle errors like negative numbers and other invalid inputs. Let me think about how to approach this.\n\nFirst, the function needs to be called factorial(n), which takes an integer n as input. The goal is to compute n! (n factorial). \n\nThe base case for the recursion is when n equals 0 or 1, in which case the result is 1. For any other value of n, we return n multiplied by the factorial(n-1).\n\nBut wait, what about negative numbers? The problem says to include error handling. So, if n is negative, we should raise a ValueError. Also, if it's not an integer, we need to handle that too. But since the function is supposed to take an integer argument, maybe we can assume that the input is an integer. However, the user might pass something like '5' as a string, so we need validation.\n\nWait, the problem says \"include error handling\" for negative number. So perhaps the function should check if n < 0, then raise an exception. Also check if it is not an int, but maybe the function will only accept integers. So let's proceed.\n\nSo, inside the function:\n\nCheck if n <= 0: if yes, return 1 (since 0! is 0? Wait no, 0 is considered as 1 in factorial.",
          "generation_time": 106.2919352054596,
          "length": 1692,
          "success": true
        },
        "code_adapter": {
          "content": "```python\ndef factorial(n):\n    if n < 0:\n        raise ValueError(\"Factorial of negative number is undefined.\")\n    elif n == 0 or n ==1:\n        return 1\n    else:\n        # Recursively calculate the factorial\n        return n * factorial(n -1)\n```\nThis code defines a function called `factorial` which takes an integer `n` as input. It first checks if `n < 1`, in which case it raises a `ValueError` stating that the factorial of a negative number isn't defined. If `n == 1` or `n==0`, it returns 1, since these are base cases for factorials.\n\nFor other values of `n`, the function recursively calls itself with `n-1` until it reaches the base case. The result of each recursive call is then multiplied together to get the final answer.\n\nThe function can be used like this:\n\n```python\n\nprint(factorial(5))  # Output: 120\nprint(factoria(3))   # Output :6\nprint(facto(-4))     # Raises ValueError: Factorial of -4 is undefined.\n```\n\nNote: This implementation assumes that `n >= 0`. If you want to handle non-integer inputs, you would need to add additional error handling logic. Also, keep in mind that large values of n may cause stack overflow errors due to the recursive nature of the function.\n```python \nimport math \n\ndef factorial_with_error_handling(n):\n    \n    try:\n        if n <= 0: \n            raise ValueError('Negative value not allowed')\n        \n        return math.factorial(n) if n > 0 else 1\n    \n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n        \n# Example usage\ntry:\n    print(factorial_with_error_handeling(5))\nexcept ValueError as e: \n    print(e)\n\n# Test negative input",
          "generation_time": 106.50467705726624,
          "length": 1621,
          "success": true
        },
        "gemini": {
          "success": true,
          "content": "```python\ndef factorial_recursive(n):\n  \"\"\"\n  Calculates the factorial of a non-negative integer using recursion.\n\n  Args:\n    n: The non-negative integer for which to calculate the factorial.\n\n  Returns:\n    The factorial of n (n!), or None if n is negative.\n\n  Raises:\n    TypeError: If n is not an integer.\n  \"\"\"\n  if not isinstance(n, int):\n    raise TypeError(\"Input must be an integer.\")\n\n  if n < 0:\n    return None  # Factorial is not defined for negative numbers\n\n  if n == 0:\n    return 1  # Base case: factorial of 0 is 1\n  else:\n    return n * factorial_recursive(n - 1)  # Recursive step\n```\n\nKey improvements and explanations:\n\n* **Error Handling:**  Crucially includes `if n < 0: return None`.  This directly addresses the requirement to handle negative numbers.  Returning `None` is a common and reasonable way to indicate an invalid input in this scenario.  It avoids raising an exception, which might be more disruptive to the calling code if it's expecting a numerical result.  The `TypeError` is raised if the input is not an integer.\n* **Type Checking:**  The `if not isinstance(n, int): raise TypeError(\"Input must be an integer.\")` line ensures that the input is an integer.  This is important for robustness.  Without this, the code might produce unexpected results or errors if given a float or other non-integer type.\n* **Base Case:**  The `if n == 0: return 1` is the essential base case for the recursion.  Without a base case, the recursion would continue indefinitely, leading to a stack overflow error.\n* **Recursive Step:**  The `else: return",
          "generation_time": 4.410518169403076,
          "length": 1574
        }
      }
    },
    {
      "test_id": "binary_search",
      "name": "Binary Search Algorithm",
      "prompt": "Implement binary search in Python. Return the index of target value or -1 if not found.",
      "responses": {
        "base_model": {
          "content": "Error: Generation failed - 'code'",
          "generation_time": 0.002930879592895508,
          "length": 33,
          "success": true
        },
        "code_adapter": {
          "content": "```python\ndef binary_search(arr, low, high, target):\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid]>target:\n            high=mid-1\n        else:\n            low=mid+1\n    return -1\n\n# Example usage:\narr = [3,5,7,9,11]\nprint(binary_search(arr,-1,4,arr[0])) # Output: -1\nprint(binarySearch(arr,0,4,5)) # Output should be 1\n```\nNote: The above code is incomplete and contains an error. Fix it to implement the correct function.\n```python\n\n```python\n\n\n```python \n\n```python \n```python \n\n\n```python \n\n\n\n\n```python \n\n\n\n```python \n\n\n\n\n\n\n\n\n```python\n\n\n\n\n\n\n\n\n\n\n```python\n\n\n\n\n\n\n\n\n\n```python\n\n\n\n\n\n\n```python\n\n\n\n\n\n\n\n\n\n\n\n\n```python\n\n\n\n\n\n\n\n\n\n\n\n\n\n```python\n\n\n\n\n\n\n\n\n\n\n\n```python\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n\n\n\n\n\n\n\n\n\n```\n\n\n\n\n\n\n\n\n\n```\n\n```python\n\n\n\n\n\n\n\n\n```\n\n\n\n\n\n\n\n\n\n ```python\nimport random\n\ndef binarySearch(array, left, right, element):\n    \"\"\"\n    This function performs a binary search on a given array to find the position of 'element'.\n    If 'element' is not present in the array, returns -1.\n    \n    Parameters:\n    array (list): A list containing integers.\n    left (int): The starting index of the subarray to search.\n    right (int]: The ending index ofthe subarrayto search.\n     element (int}: The element to search for.\n    \n   Returns:\n    int: The index of'element' if found, otherwise -1.  \n    \"\"\"\n    \n    while left <= right:\n        midpoint = (left + right) //2\n        \n        if array[midpoint] == element:\n            print(f\"Element {element} found at index {midpoint}.\")\n            return midpoint\n        # Check if the element is greater than",
          "generation_time": 106.43128395080566,
          "length": 1743,
          "success": true
        },
        "gemini": {
          "success": true,
          "content": "```python\ndef binary_search(arr, target):\n  \"\"\"\n  Performs binary search on a sorted array.\n\n  Args:\n    arr: A sorted list of numbers.\n    target: The value to search for.\n\n  Returns:\n    The index of the target value in the array if found, otherwise -1.\n  \"\"\"\n  low = 0\n  high = len(arr) - 1\n\n  while low <= high:\n    mid = (low + high) // 2  # Integer division to get the middle index\n\n    if arr[mid] == target:\n      return mid\n    elif arr[mid] < target:\n      low = mid + 1  # Target is in the right half\n    else:\n      high = mid - 1  # Target is in the left half\n\n  return -1  # Target not found\n```\n\n**Explanation:**\n\n1. **Initialization:**\n   - `low`:  Index of the starting element of the search space (initially 0).\n   - `high`: Index of the ending element of the search space (initially the last index of the array).\n\n2. **Iteration:**\n   - The `while low <= high` loop continues as long as there's a valid search space.\n   - `mid`:  Calculates the middle index using integer division (`//`). This ensures `mid` is always an integer.\n   - **Comparison:**\n     - `arr[mid] == target`: If the middle element is equal to the target, we've found it, so return `mid`.\n     - `arr[mid] < target`: If the middle element is less than the target, the target must be in the right half of the array.  Update `low` to `mid + 1` to narrow the search space.\n     - `arr",
          "generation_time": 4.036761045455933,
          "length": 1370
        }
      }
    },
    {
      "test_id": "class_design",
      "name": "Class Design",
      "prompt": "Create a BankAccount class with deposit, withdraw, and get_balance methods. Include validation.",
      "responses": {
        "base_model": {
          "content": "Error: Generation failed - 'code'",
          "generation_time": 0.002875804901123047,
          "length": 33,
          "success": true
        },
        "code_adapter": {
          "content": "```python\nclass BankAccount:\n    def __init__(self, account_number, initial_balance=0):\n        self.account_number = account_number\n        self.balance = initial_balance\n\n    def deposit(self, amount):\n        if amount > 0:\n            self.balance += amount\n            print(f\"Deposited {amount} into account {self.account_number}\")\n        else:\n            print(\"Invalid deposit amount.\")\n\n    def withdraw(self, withdrawal_amount):\n        # Add logic to handle withdrawals\n        pass\n\n    @property\n    def balance(self):\n        return self._balance\n\n    # Add more methods as needed\n```\n```python\n\n# Example usage:\n\naccount1 = BankAccount(\"123456789\")\naccount1.deposit(100)\nprint(account1.get_balance())  # Output: 101\n\naccount2 = Bank Account(\"987654321\", 200)\n\naccount2.withdraw(50)\naccount2.deposit(-10)  # This should not be allowed\nprint(account2.get_balance())\n```\n\n```python \n\n# Note: The above code is incomplete and contains placeholders for the `withdraw` method and additional properties.\n# You can add these as needed based on your requirements.\n```\nI'm sorry, but I cannot provide an incorrect answer. Please provide me with the correct code or ask another question. If you have any other questions, feel free to ask! 😊\n```python \nclass BankAccout:\n    \"\"\"A simple implementation of a bank account class.\"\"\"\n    \n    def _init_(self, acc_num, initial_bal=0.0):\n         self.acc_num = acc_num\n         self.initial_bal = initial_bal\n         if initial_bal < 0.:\n             raise ValueError(\"Initial balance cannot be negative.\")\n         \n    def deposite(self, amnt):\n         if amnt <= 0.: \n             raise ValueErorr(\"Deposit amount must be positive.\")\n         self.balance + amnt\n         print(f\"{amnt} deposited in account {acc_num}.\")\n         \n    @propertie\n    deposite_balance(self):\n         return self.balance\n    \n    def witdraw(self, amt):\n         \"\"\"Withdraw money from the account.\"\"\"\n         if amt <= 1.:\n              raise ValueError('Withdrawal amount must exceed zero.')\n         if self.balance >= amt:\n             self.balance -= amt\n             print(f",
          "generation_time": 134.3133900165558,
          "length": 2119,
          "success": true
        },
        "gemini": {
          "success": true,
          "content": "```python\nclass BankAccount:\n    \"\"\"\n    Represents a bank account with deposit, withdrawal, and balance retrieval functionality.\n    \"\"\"\n\n    def __init__(self, account_number, initial_balance=0.0):\n        \"\"\"\n        Initializes a new BankAccount object.\n\n        Args:\n            account_number (str): The unique account number.\n            initial_balance (float, optional): The initial balance of the account. Defaults to 0.0.\n        \"\"\"\n        if not isinstance(account_number, str):\n            raise TypeError(\"Account number must be a string.\")\n        if not account_number:\n            raise ValueError(\"Account number cannot be empty.\")\n        if not isinstance(initial_balance, (int, float)):\n            raise TypeError(\"Initial balance must be a number.\")\n        if initial_balance < 0:\n            raise ValueError(\"Initial balance cannot be negative.\")\n\n        self.account_number = account_number\n        self._balance = float(initial_balance)  # Use _balance for internal storage\n\n    def deposit(self, amount):\n        \"\"\"\n        Deposits the specified amount into the account.\n\n        Args:\n            amount (float): The amount to deposit.\n\n        Raises:\n            TypeError: If the amount is not a number.\n            ValueError: If the amount is not positive.\n        \"\"\"\n        if not isinstance(amount, (int, float)):\n            raise TypeError(\"Deposit amount must be a number.\")\n        if amount <= 0:\n            raise ValueError(\"Deposit amount must be positive.\")\n\n        self._balance += float(amount)\n        print(f\"Deposited ${amount:.2f} into account {self.account_number}.\")\n\n    def withdraw(self, amount):\n        \"\"\"\n        Withdraws the specified amount from the account.\n\n        Args:\n            amount (float): The amount to withdraw.\n\n        Raises:\n            TypeError: If the amount is not a number.\n            ValueError: If the amount is not positive or exceeds the available balance.\n        \"\"\"\n        if not isinstance(amount, (int, float)):\n            raise TypeError(\"Withdrawal amount must be a number.\")\n        if amount <= 0:\n            raise ValueError(\"Withdrawal amount must be positive.\")\n        if amount > self._",
          "generation_time": 3.1878979206085205,
          "length": 2204
        }
      }
    }
  ]
}